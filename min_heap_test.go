// Code generated by go2go; DO NOT EDIT.


//line min_heap_test.go2:1
package prioqueue

//line min_heap_test.go2:1
import (
//line min_heap_test.go2:1
 "github.com/stretchr/testify/assert"
//line min_heap_test.go2:1
 "github.com/stretchr/testify/require"
//line min_heap_test.go2:1
 "math/rand"
//line min_heap_test.go2:1
 "testing"
//line min_heap_test.go2:1
)

//line min_heap_test.go2:7
func TestMinHeap(t *testing.T) {
	var pq instantiate୦୦MinHeap୦float32
	runTests(t, &pq, assertSmallestFirst)

	pq2 := instantiate୦୦NewMinHeap୦float32(10)
	runTests(t, pq2, assertSmallestFirst)
}

func TestMinHeap_Random(t *testing.T) {
	pq := instantiate୦୦NewMinHeap୦float32(10)
	runTestsN(t, pq, assertSmallestFirst, 10_000)
}

func TestInference(t *testing.T) {
				i := instantiate୦୦NewItem୦float64(123, 4.5)

//line min_heap_test.go2:24
 t.Log(i)
}

//line min_heap_test.go2:25
type instantiate୦୦MinHeap୦float32 struct {
//line min_heap.go2:26
 items []*instantiate୦୦Item୦float32
}

//line min_heap.go2:65
func (h *instantiate୦୦MinHeap୦float32,) Top() (id uint32, prio float32,

//line min_heap.go2:65
) {
	i := h.TopItem()
	if i == nil {
		return 0, 0
	}

	return i.ID, i.Prio
}

//line min_heap.go2:76
func (h *instantiate୦୦MinHeap୦float32,) TopItem() *instantiate୦୦Item୦float32 {
	if len(h.items) == 0 {
		return nil
	}
	return h.items[0]
}

//line min_heap.go2:84
func (h *instantiate୦୦MinHeap୦float32,) Len() int {
	return len(h.items)
}

//line min_heap.go2:92
func (h *instantiate୦୦MinHeap୦float32,) Reset() {
	h.items = h.items[0:0]
}

//line min_heap.go2:97
func (h *instantiate୦୦MinHeap୦float32,) Push(id uint32, priority float32,

//line min_heap.go2:97
) {
	item := instantiate୦୦NewItem୦float32(id, priority)
	h.PushItem(item)
}

//line min_heap.go2:103
func (h *instantiate୦୦MinHeap୦float32,) PushItem(item *instantiate୦୦Item୦float32,) {

//line min_heap.go2:106
 h.items = append(h.items, item)

	i := len(h.items) - 1
	for i > 0 {
		parent := (i - 1) / 2
		if h.items[parent].Prio <= h.items[i].Prio {

			return
		}

		h.items[i], h.items[parent] = h.items[parent], h.items[i]
		i = parent
	}
}

//line min_heap.go2:128
func (h *instantiate୦୦MinHeap୦float32,) Pop() (id uint32, priority float32,

//line min_heap.go2:128
) {
	i := h.PopItem()
	if i == nil {
		return 0, 0
	}

	return i.ID, i.Prio
}

//line min_heap.go2:138
func (h *instantiate୦୦MinHeap୦float32,) PopItem() *instantiate୦୦Item୦float32 {
	if len(h.items) == 0 {
		return nil
	}

				root := h.items[0]
				maxIndex := len(h.items) - 1

//line min_heap.go2:147
 h.items[0], h.items[maxIndex] = h.items[maxIndex], h.items[0]
				h.items = h.items[0:maxIndex]

//line min_heap.go2:151
 h.shiftDown()

	return root
}

//line min_heap.go2:158
func (h *instantiate୦୦MinHeap୦float32,) shiftDown() {
	maxIndex := len(h.items) - 1
	i := 0
	for {
		j := 2*i + 1

		if j > maxIndex || j < 0 {
			break
		}

		if j < maxIndex && h.items[j].Prio > h.items[j+1].Prio {
			j++
		}

		if h.items[i].Prio <= h.items[j].Prio {

			break
		}

//line min_heap.go2:178
  h.items[i], h.items[j] = h.items[j], h.items[i]

//line min_heap.go2:181
  i = j
	}
}
//line min_heap.go2:55
func instantiate୦୦NewMinHeap୦float32(size int) *instantiate୦୦MinHeap୦float32 {
	h := new(instantiate୦୦MinHeap୦float32)
	if size > 0 {
		h.items = make([]*instantiate୦୦Item୦float32, 0, size)
	}
	return h
}
//line min_heap.go2:41
func instantiate୦୦NewItem୦float64(id uint32, prio float64,) *instantiate୦୦Item୦float64 {
	return &instantiate୦୦Item୦float64{
		ID:   id,
		Prio: prio,
	}
}

//line min_heap.go2:46
type instantiate୦୦Item୦float32 struct {
//line min_heap.go2:37
 ID   uint32
			Prio float32
}

func instantiate୦୦NewItem୦float32(id uint32, prio float32,) *instantiate୦୦Item୦float32 {
	return &instantiate୦୦Item୦float32{
		ID:   id,
		Prio: prio,
	}
}

//line min_heap.go2:46
type instantiate୦୦Item୦float64 struct {
//line min_heap.go2:37
 ID   uint32
			Prio float64
}

//line min_heap.go2:39
var _ = assert.AnError

//line min_heap.go2:39
type _ require.Assertions

//line min_heap.go2:39
var _ = rand.ExpFloat64
//line min_heap.go2:39
var _ = testing.AllocsPerRun
